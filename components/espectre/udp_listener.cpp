/*
 * ESPectre - UDP Listener Implementation
 * 
 * Author: Francesco Pace <francesco.pace@gmail.com>
 * License: GPLv3
 */

#include "udp_listener.h"
#include "esphome/core/log.h"
#include "lwip/sockets.h"
#include "lwip/netdb.h"
#include <cstring>
#include <fcntl.h>

namespace esphome {
namespace espectre {

static const char *TAG = "UDPListener";

void UDPListener::init(uint16_t port) {
  port_ = port;
  running_ = false;
  sock_ = -1;
  ESP_LOGD(TAG, "UDP Listener initialized (port: %u)", port_);
}

bool UDPListener::start() {
  if (running_) {
    ESP_LOGW(TAG, "UDP Listener already running");
    return true;
  }
  
  // Create UDP socket
  sock_ = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  if (sock_ < 0) {
    ESP_LOGE(TAG, "Failed to create UDP socket: errno %d", errno);
    return false;
  }
  
  // Set socket to non-blocking
  int flags = fcntl(sock_, F_GETFL, 0);
  if (fcntl(sock_, F_SETFL, flags | O_NONBLOCK) < 0) {
    ESP_LOGW(TAG, "Failed to set socket non-blocking");
  }
  
  // Allow reuse of address
  int reuse = 1;
  if (setsockopt(sock_, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0) {
    ESP_LOGW(TAG, "Failed to set SO_REUSEADDR");
  }
  
  // Bind to port
  struct sockaddr_in addr;
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port_);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  
  if (bind(sock_, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
    ESP_LOGE(TAG, "Failed to bind UDP socket to port %u: errno %d", port_, errno);
    close(sock_);
    sock_ = -1;
    return false;
  }
  
  running_ = true;
  ESP_LOGI(TAG, "ðŸ“¡ UDP Listener started on port %u (external traffic mode)", port_);
  
  return true;
}

void UDPListener::stop() {
  if (!running_) {
    return;
  }
  
  if (sock_ >= 0) {
    close(sock_);
    sock_ = -1;
  }
  
  running_ = false;
  ESP_LOGI(TAG, "UDP Listener stopped");
}

void UDPListener::loop() {
  if (!running_ || sock_ < 0) {
    return;
  }
  
  // Non-blocking receive - just drain any pending packets
  // The CSI callback is triggered by the WiFi driver when packets arrive,
  // we just need to consume them so the socket buffer doesn't fill up
  char buf[64];
  struct sockaddr_in src_addr;
  socklen_t addr_len = sizeof(src_addr);
  
  // Drain all pending packets (non-blocking)
  while (true) {
    ssize_t len = recvfrom(sock_, buf, sizeof(buf), 0, 
                           (struct sockaddr *)&src_addr, &addr_len);
    if (len < 0) {
      // EAGAIN/EWOULDBLOCK means no more data available
      if (errno == EAGAIN || errno == EWOULDBLOCK) {
        break;
      }
      // Other error
      ESP_LOGW(TAG, "recvfrom error: errno %d", errno);
      break;
    }
    // Packet received and discarded - CSI was generated by WiFi driver
  }
}

}  // namespace espectre
}  // namespace esphome

