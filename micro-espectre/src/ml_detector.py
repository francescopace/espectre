"""
Micro-ESPectre - ML Motion Detector

Neural network-based motion detector implementing the IDetector interface.
Uses pre-trained weights from ml_weights.py (auto-generated by training script).

Usage:
    from ml_detector import MLDetector
    
    detector = MLDetector()
    detector.process_packet(csi_data, subcarriers)
    metrics = detector.update_state()

Author: Francesco Pace <francesco.pace@gmail.com>
License: GPLv3
"""
import math

try:
    from src.detector_interface import IDetector, MotionState
    from src.segmentation import SegmentationContext
    from src.features import extract_features_by_name, DEFAULT_FEATURES
    from src.utils import extract_phases
    from src.ml_weights import (
        FEATURE_MEAN, FEATURE_SCALE,
        W1, B1, W2, B2, W3, B3
    )
except ImportError:
    from detector_interface import IDetector, MotionState
    from segmentation import SegmentationContext
    from features import extract_features_by_name, DEFAULT_FEATURES
    from utils import extract_phases
    from ml_weights import (
        FEATURE_MEAN, FEATURE_SCALE,
        W1, B1, W2, B2, W3, B3
    )

# Re-export for convenience
__all__ = ['MLDetector', 'predict', 'is_motion', 'ML_SUBCARRIERS']

# Fixed subcarriers for ML (12 evenly distributed across 64, excluding guard bands and DC)
# These must match the subcarriers used during model training
ML_SUBCARRIERS = [11, 14, 17, 21, 24, 28, 31, 35, 39, 42, 46, 49]


# ============================================================================
# Neural Network Inference Functions
# ============================================================================

def relu(x):
    """ReLU activation function."""
    return x if x > 0 else 0.0


def sigmoid(x):
    """Sigmoid activation function with overflow protection."""
    if x < -20:
        return 0.0
    if x > 20:
        return 1.0
    return 1.0 / (1.0 + math.exp(-x))


def normalize_features(features):
    """Normalize features using pre-computed mean and scale."""
    normalized = []
    for i in range(len(features)):
        normalized.append((features[i] - FEATURE_MEAN[i]) / FEATURE_SCALE[i])
    return normalized


def predict(features):
    """
    Predict motion probability from 12 features.
    
    Architecture: 12 -> 16 (ReLU) -> 8 (ReLU) -> 1 (Sigmoid)
    
    Args:
        features: List of 12 feature values
    
    Returns:
        float: Motion probability (0.0 to 1.0)
    """
    # Normalize
    x = normalize_features(features)
    
    # Layer 1: 12 -> 16 (ReLU)
    h1 = []
    for j in range(16):
        val = B1[j]
        for i in range(12):
            val += x[i] * W1[i][j]
        h1.append(relu(val))
    
    # Layer 2: 16 -> 8 (ReLU)
    h2 = []
    for j in range(8):
        val = B2[j]
        for i in range(16):
            val += h1[i] * W2[i][j]
        h2.append(relu(val))
    
    # Layer 3: 8 -> 1 (Sigmoid)
    out = B3[0]
    for i in range(8):
        out += h2[i] * W3[i][0]
    
    return sigmoid(out)


def is_motion(features, threshold=0.5):
    """
    Detect motion from features.
    
    Args:
        features: List of 12 feature values
        threshold: Detection threshold (default: 0.5)
    
    Returns:
        bool: True if motion detected
    """
    return predict(features) > threshold


# ============================================================================
# MLDetector Class
# ============================================================================


class MLDetector(IDetector):
    """
    Neural Network-based motion detector.
    
    Uses a pre-trained MLP (12 -> 16 -> 8 -> 1) to classify
    motion based on turbulence features extracted from CSI data.
    
    Algorithm:
    1. Calculate spatial turbulence (std of subcarrier amplitudes)
    2. Store in circular buffer (window_size packets)
    3. Extract 12 statistical features from buffer
    4. Run neural network inference
    5. Compare probability to threshold for state decision
    """
    
    def __init__(self, window_size=75, threshold=0.5,
                 enable_lowpass=False, lowpass_cutoff=11.0,
                 enable_hampel=False, hampel_window=7, hampel_threshold=4.0,
                 use_cv_normalization=False):
        """
        Initialize ML detector.
        
        Args:
            window_size: Feature extraction window size (default: 75, matches C++ DETECTOR_DEFAULT_WINDOW_SIZE)
            threshold: Motion probability threshold (default: 0.5)
            enable_lowpass: Enable low-pass filter (default: False)
            lowpass_cutoff: Low-pass cutoff frequency Hz (default: 11.0)
            enable_hampel: Enable Hampel filter (default: False)
            hampel_window: Hampel window size (default: 7)
            hampel_threshold: Hampel threshold in MAD (default: 4.0)
            use_cv_normalization: Use CV (std/mean) instead of raw std (default: False)
                                  Set True for chips without gain lock (e.g., ESP32)
        """
        # Use SegmentationContext for turbulence calculation and filtering
        self._context = SegmentationContext(
            window_size=window_size,
            threshold=1.0,  # Not used, we use probability threshold
            enable_lowpass=enable_lowpass,
            lowpass_cutoff=lowpass_cutoff,
            enable_hampel=enable_hampel,
            hampel_window=hampel_window,
            hampel_threshold=hampel_threshold
        )
        # CV normalization: True for chips without gain lock (ESP32)
        # False for chips with gain lock (C3, C6, S3) - raw std is more sensitive
        self._context.use_cv_normalization = use_cv_normalization
        self._threshold = threshold
        self._packet_count = 0
        self._motion_count = 0
        self._state = MotionState.IDLE
        self._current_probability = 0.0
        
        # For tracking (optional)
        self.probability_history = []
        self.state_history = []
        self.track_data = False
        
        # Store current amplitudes and phases for feature extraction
        self._current_amplitudes = None
        self._current_phases = None
    
    def process_packet(self, csi_data, selected_subcarriers=None):
        """
        Process a CSI packet.
        
        Args:
            csi_data: Raw CSI data (int8 I/Q pairs)
            selected_subcarriers: Subcarrier indices to use
        """
        self._packet_count += 1
        
        # Calculate spatial turbulence using instance method (CV-normalized)
        # Also get amplitudes for cross-subcarrier features
        turbulence, amplitudes = self._context.calculate_spatial_turbulence(
            csi_data, selected_subcarriers, return_amplitudes=True
        )
        
        # Store amplitudes for feature extraction
        self._current_amplitudes = amplitudes
        
        # Extract phases for phase-based features
        self._current_phases = extract_phases(csi_data, selected_subcarriers)
        
        # Add to buffer
        self._context.add_turbulence(turbulence)
    
    def update_state(self):
        """
        Run inference and update state.
        
        Returns:
            dict: Current metrics including state and probability
        """
        if not self.is_ready():
            return {
                'state': self._state,
                'probability': 0.0,
                'threshold': self._threshold
            }
        
        # Extract features from turbulence buffer
        features = self._extract_features()
        
        # Run neural network
        self._current_probability = predict(features)
        
        # Update state
        if self._current_probability > self._threshold:
            self._state = MotionState.MOTION
        else:
            self._state = MotionState.IDLE
        
        if self.track_data:
            self.probability_history.append(self._current_probability)
            state_str = 'MOTION' if self._state == MotionState.MOTION else 'IDLE'
            self.state_history.append(state_str)
            if self._state == MotionState.MOTION:
                self._motion_count += 1
        
        return {
            'state': self._state,
            'probability': self._current_probability,
            'threshold': self._threshold
        }
    
    def _extract_features(self):
        """
        Extract 12 features from turbulence buffer using centralized extractor.
        
        IMPORTANT: The turbulence_buffer is a circular buffer. After wrap-around,
        a simple slice [:buffer_count] would NOT be in chronological order.
        Features like slope, delta, zcr, and autocorr depend on temporal order.
        
        We reconstruct the chronological order: [oldest ... newest]
        """
        ctx = self._context
        
        # Build chronological list from circular buffer
        if ctx.buffer_count < ctx.window_size:
            # Buffer not full yet: data is in order from index 0
            turb_list = ctx.turbulence_buffer[:ctx.buffer_count]
        else:
            # Buffer is full and has wrapped: reconstruct order
            # buffer_index points to the NEXT write position (oldest value)
            idx = ctx.buffer_index
            turb_list = ctx.turbulence_buffer[idx:] + ctx.turbulence_buffer[:idx]
        
        return extract_features_by_name(
            turb_list, len(turb_list), 
            amplitudes=self._current_amplitudes,
            feature_names=DEFAULT_FEATURES,
            phases=self._current_phases
        )
    
    def get_state(self):
        """Get current motion state."""
        return self._state
    
    def get_motion_metric(self):
        """Get current motion probability."""
        return self._current_probability
    
    def get_threshold(self):
        """Get current probability threshold."""
        return self._threshold
    
    def set_threshold(self, threshold):
        """Set probability threshold."""
        if 0.0 <= threshold <= 1.0:
            self._threshold = threshold
            return True
        return False
    
    def is_ready(self):
        """Check if buffer is full."""
        return self._context.buffer_count >= self._context.window_size
    
    def reset(self):
        """Reset detector state."""
        self._context.reset(full=True)
        self._state = MotionState.IDLE
        self._current_probability = 0.0
        self._motion_count = 0
        self.probability_history = []
        self.state_history = []
    
    def get_name(self):
        """Get detector name."""
        return "ML"
    
    @property
    def total_packets(self):
        """Total packets processed."""
        return self._packet_count
    
    def get_motion_count(self):
        """Get number of motion detections (for tracking)."""
        return self._motion_count
