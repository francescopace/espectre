"""
Micro-ESPectre - ML Motion Detector

Neural network-based motion detector implementing the IDetector interface.
Uses pre-trained weights from ml_weights.py (auto-generated by training script).

Usage:
    from ml_detector import MLDetector

    detector = MLDetector()
    detector.process_packet(csi_data, subcarriers)
    metrics = detector.update_state()
    # metrics['gesture'] contains the predicted class name (e.g. 'wave')

Author: Francesco Pace <francesco.pace@gmail.com>
License: GPLv3
"""
import math

try:
    from src.detector_interface import IDetector, MotionState
    from src.segmentation import SegmentationContext
    from src.features import extract_features_by_name, DEFAULT_FEATURES
    from src.utils import extract_phases
    import src.ml_weights as _w
except ImportError:
    from detector_interface import IDetector, MotionState
    from segmentation import SegmentationContext
    from features import extract_features_by_name, DEFAULT_FEATURES
    from utils import extract_phases
    import ml_weights as _w

FEATURE_MEAN = _w.FEATURE_MEAN
FEATURE_SCALE = _w.FEATURE_SCALE
CLASS_LABELS = _w.CLASS_LABELS
NUM_CLASSES = _w.NUM_CLASSES

# Collect weight layers dynamically: supports any architecture (W1/B1, W2/B2, ...)
LAYERS = []
_i = 1
while hasattr(_w, 'W' + str(_i)):
    LAYERS.append((getattr(_w, 'W' + str(_i)), getattr(_w, 'B' + str(_i))))
    _i += 1

__all__ = ['MLDetector', 'predict_class', 'ML_SUBCARRIERS']

# Fixed subcarriers for ML (12 evenly distributed across 64, excluding guard bands and DC)
# These must match the subcarriers used during model training
ML_SUBCARRIERS = [11, 14, 17, 21, 24, 28, 31, 35, 39, 42, 46, 49]


# ============================================================================
# Neural Network Inference
# ============================================================================

def relu(x):
    """ReLU activation function."""
    return x if x > 0 else 0.0


def softmax(logits):
    """Softmax activation with numerical stability."""
    max_val = max(logits)
    exp_vals = [math.exp(v - max_val) for v in logits]
    total = sum(exp_vals)
    return [e / total for e in exp_vals]


def normalize_features(features):
    """Normalize features using pre-computed mean and scale."""
    return [(features[i] - FEATURE_MEAN[i]) / FEATURE_SCALE[i] for i in range(len(features))]


def predict_class(features):
    """
    Predict gesture/motion class from 12 features.

    Architecture: 12 -> hidden... -> N (Softmax), any number of layers.

    Args:
        features: List of 12 feature values

    Returns:
        tuple: (class_id, class_name, confidence)
               class_id=0 is IDLE, class_id>0 is some form of motion/gesture
    """
    h = normalize_features(features)

    for idx, (W, B) in enumerate(LAYERS):
        out_size = len(B)
        is_last = (idx == len(LAYERS) - 1)
        new_h = []
        for j in range(out_size):
            val = B[j]
            for i in range(len(h)):
                val += h[i] * W[i][j]
            new_h.append(val if is_last else relu(val))
        h = new_h

    probs = softmax(h)
    class_id = probs.index(max(probs))
    return class_id, CLASS_LABELS[class_id], probs[class_id]


def predict_probability(features):
    """
    Return 1 - prob[idle], mirroring MLDetector::predict() in C++.

    Used by tests that verify numerical alignment between Python and C++ inference.

    Args:
        features: List of 12 feature values

    Returns:
        float: Probability of being non-idle (0.0 - 1.0)
    """
    h = normalize_features(features)

    for idx, (W, B) in enumerate(LAYERS):
        out_size = len(B)
        is_last = (idx == len(LAYERS) - 1)
        new_h = []
        for j in range(out_size):
            val = B[j]
            for i in range(len(h)):
                val += h[i] * W[i][j]
            new_h.append(val if is_last else relu(val))
        h = new_h

    probs = softmax(h)
    return 1.0 - probs[0]


# ============================================================================
# MLDetector Class
# ============================================================================


class MLDetector(IDetector):
    """
    Neural Network-based motion and gesture detector.

    Uses a pre-trained MLP (architecture defined in ml_weights.py) to classify
    motion and specific gestures from CSI turbulence features.

    Algorithm:
    1. Calculate spatial turbulence (std of subcarrier amplitudes)
    2. Store in circular buffer (window_size packets)
    3. Extract 12 statistical features from buffer
    4. Run neural network inference (softmax over N classes)
    5. class_id=0 → IDLE, class_id>0 → MOTION (with gesture name)
    """

    def __init__(self, window_size=75, threshold=0.5,
                 enable_lowpass=False, lowpass_cutoff=11.0,
                 enable_hampel=False, hampel_window=7, hampel_threshold=4.0,
                 use_cv_normalization=False):
        """
        Initialize ML detector.

        Args:
            window_size: Feature extraction window size (default: 75)
            threshold: Unused in multiclass mode, kept for interface compatibility
            enable_lowpass: Enable low-pass filter (default: False)
            lowpass_cutoff: Low-pass cutoff frequency Hz (default: 11.0)
            enable_hampel: Enable Hampel filter (default: False)
            hampel_window: Hampel window size (default: 7)
            hampel_threshold: Hampel threshold in MAD (default: 4.0)
            use_cv_normalization: Use CV (std/mean) normalization (default: False)
        """
        self._context = SegmentationContext(
            window_size=window_size,
            threshold=1.0,
            enable_lowpass=enable_lowpass,
            lowpass_cutoff=lowpass_cutoff,
            enable_hampel=enable_hampel,
            hampel_window=hampel_window,
            hampel_threshold=hampel_threshold
        )
        self._context.use_cv_normalization = use_cv_normalization
        self._threshold = threshold
        self._packet_count = 0
        self._motion_count = 0
        self._state = MotionState.IDLE
        self._current_probability = 0.0
        self._current_gesture = None

        self.probability_history = []
        self.state_history = []
        self.track_data = False

        self._current_amplitudes = None
        self._current_phases = None

    def process_packet(self, csi_data, selected_subcarriers=None):
        """Process a CSI packet and update the turbulence buffer."""
        self._packet_count += 1
        turbulence, amplitudes = self._context.calculate_spatial_turbulence(
            csi_data, selected_subcarriers, return_amplitudes=True
        )
        self._current_amplitudes = amplitudes
        self._current_phases = extract_phases(csi_data, selected_subcarriers)
        self._context.add_turbulence(turbulence)

    def update_state(self):
        """
        Run inference and update state.

        Returns:
            dict: {state, probability, threshold, gesture}
                  gesture is the predicted class name (e.g. 'wave', 'idle')
        """
        if not self.is_ready():
            return {
                'state': self._state,
                'probability': 0.0,
                'threshold': self._threshold,
                'gesture': None,
            }

        features = self._extract_features()
        class_id, class_name, _ = predict_class(features)
        # Use 1 - prob[idle] as the motion metric, matching C++ MLDetector::predict().
        # This is always low when idle and high when motion/gesture, so the threshold
        # comparison (metric > 0.5 → MOTION) is consistent and readable in the UI.
        non_idle_prob = predict_probability(features)

        self._current_probability = non_idle_prob
        self._current_gesture = class_name
        self._state = MotionState.MOTION if class_id != 0 else MotionState.IDLE

        if self.track_data:
            self.probability_history.append(non_idle_prob)
            self.state_history.append('MOTION' if class_id != 0 else 'IDLE')
            if class_id != 0:
                self._motion_count += 1

        return {
            'state': self._state,
            'probability': non_idle_prob,
            'threshold': self._threshold,
            'gesture': class_name,
        }

    def _extract_features(self):
        """
        Extract 12 features from turbulence buffer in chronological order.

        The turbulence_buffer is a circular buffer. After wrap-around,
        a simple slice [:buffer_count] would NOT be in chronological order.
        Features like slope, zcr, and autocorr depend on temporal order.
        """
        ctx = self._context
        if ctx.buffer_count < ctx.window_size:
            turb_list = ctx.turbulence_buffer[:ctx.buffer_count]
        else:
            idx = ctx.buffer_index
            turb_list = ctx.turbulence_buffer[idx:] + ctx.turbulence_buffer[:idx]

        return extract_features_by_name(
            turb_list, len(turb_list),
            amplitudes=self._current_amplitudes,
            feature_names=DEFAULT_FEATURES,
            phases=self._current_phases
        )

    def get_state(self):
        """Get current motion state."""
        return self._state

    def get_motion_metric(self):
        """Get current prediction confidence."""
        return self._current_probability

    def get_threshold(self):
        """Get threshold (interface compatibility)."""
        return self._threshold

    def set_threshold(self, threshold):
        """Set threshold (interface compatibility)."""
        if 0.0 <= threshold <= 1.0:
            self._threshold = threshold
            return True
        return False

    def is_ready(self):
        """Check if buffer is full."""
        return self._context.buffer_count >= self._context.window_size

    def reset(self):
        """Reset detector state."""
        self._context.reset(full=True)
        self._state = MotionState.IDLE
        self._current_probability = 0.0
        self._current_gesture = None
        self._motion_count = 0
        self.probability_history = []
        self.state_history = []

    def get_name(self):
        """Get detector name."""
        return "ML"

    @property
    def total_packets(self):
        """Total packets processed."""
        return self._packet_count

    def get_motion_count(self):
        """Get number of motion detections."""
        return self._motion_count
