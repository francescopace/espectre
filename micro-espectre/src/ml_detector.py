"""
Micro-ESPectre - ML Motion Detector

Neural network-based motion detector implementing the IDetector interface.
Uses pre-trained weights from ml_weights.py (auto-generated by training script).

Usage:
    from ml_detector import MLDetector
    
    detector = MLDetector()
    detector.process_packet(csi_data, subcarriers)
    metrics = detector.update_state()

Author: Francesco Pace <francesco.pace@gmail.com>
License: GPLv3
"""
import math

try:
    from src.detector_interface import IDetector, MotionState
    from src.segmentation import SegmentationContext
    from src.features import extract_all_features
    from src.ml_weights import (
        FEATURE_MEAN, FEATURE_SCALE,
        W1, B1, W2, B2, W3, B3
    )
except ImportError:
    from detector_interface import IDetector, MotionState
    from segmentation import SegmentationContext
    from features import extract_all_features
    from ml_weights import (
        FEATURE_MEAN, FEATURE_SCALE,
        W1, B1, W2, B2, W3, B3
    )

# Re-export for convenience
__all__ = ['MLDetector', 'predict', 'is_motion']


# ============================================================================
# Neural Network Inference Functions
# ============================================================================

def relu(x):
    """ReLU activation function."""
    return x if x > 0 else 0.0


def sigmoid(x):
    """Sigmoid activation function with overflow protection."""
    if x < -20:
        return 0.0
    if x > 20:
        return 1.0
    return 1.0 / (1.0 + math.exp(-x))


def normalize_features(features):
    """Normalize features using pre-computed mean and scale."""
    normalized = []
    for i in range(len(features)):
        normalized.append((features[i] - FEATURE_MEAN[i]) / FEATURE_SCALE[i])
    return normalized


def predict(features):
    """
    Predict motion probability from 12 features.
    
    Architecture: 12 -> 16 (ReLU) -> 8 (ReLU) -> 1 (Sigmoid)
    
    Args:
        features: List of 12 feature values
    
    Returns:
        float: Motion probability (0.0 to 1.0)
    """
    # Normalize
    x = normalize_features(features)
    
    # Layer 1: 12 -> 16 (ReLU)
    h1 = []
    for j in range(16):
        val = B1[j]
        for i in range(12):
            val += x[i] * W1[i][j]
        h1.append(relu(val))
    
    # Layer 2: 16 -> 8 (ReLU)
    h2 = []
    for j in range(8):
        val = B2[j]
        for i in range(16):
            val += h1[i] * W2[i][j]
        h2.append(relu(val))
    
    # Layer 3: 8 -> 1 (Sigmoid)
    out = B3[0]
    for i in range(8):
        out += h2[i] * W3[i][0]
    
    return sigmoid(out)


def is_motion(features, threshold=0.5):
    """
    Detect motion from features.
    
    Args:
        features: List of 12 feature values
        threshold: Detection threshold (default: 0.5)
    
    Returns:
        bool: True if motion detected
    """
    return predict(features) > threshold


# ============================================================================
# MLDetector Class
# ============================================================================


class MLDetector(IDetector):
    """
    Neural Network-based motion detector.
    
    Uses a pre-trained MLP (12 -> 16 -> 8 -> 1) to classify
    motion based on turbulence features extracted from CSI data.
    
    Algorithm:
    1. Calculate spatial turbulence (std of subcarrier amplitudes)
    2. Store in circular buffer (window_size packets)
    3. Extract 12 statistical features from buffer
    4. Run neural network inference
    5. Compare probability to threshold for state decision
    """
    
    def __init__(self, window_size=50, threshold=0.5):
        """
        Initialize ML detector.
        
        Args:
            window_size: Feature extraction window size (default: 50)
            threshold: Motion probability threshold (default: 0.5)
        """
        # Use SegmentationContext for turbulence calculation
        self._context = SegmentationContext(
            window_size=window_size,
            threshold=1.0  # Not used, we use probability threshold
        )
        self._threshold = threshold
        self._packet_count = 0
        self._motion_count = 0
        self._state = MotionState.IDLE
        self._current_probability = 0.0
        self._last_amplitudes = None
        
        # For tracking (optional)
        self.probability_history = []
        self.state_history = []
        self.track_data = False
    
    def process_packet(self, csi_data, selected_subcarriers=None):
        """
        Process a CSI packet.
        
        Args:
            csi_data: Raw CSI data (int8 I/Q pairs)
            selected_subcarriers: Subcarrier indices to use
        """
        self._packet_count += 1
        
        # Calculate spatial turbulence and store amplitudes
        turbulence, amplitudes = SegmentationContext.compute_spatial_turbulence(
            csi_data, selected_subcarriers
        )
        self._last_amplitudes = amplitudes
        
        # Add to buffer
        self._context.add_turbulence(turbulence)
    
    def update_state(self):
        """
        Run inference and update state.
        
        Returns:
            dict: Current metrics including state and probability
        """
        if not self.is_ready():
            return {
                'state': self._state,
                'probability': 0.0,
                'threshold': self._threshold
            }
        
        # Extract features from turbulence buffer
        features = self._extract_features()
        
        # Run neural network
        self._current_probability = predict(features)
        
        # Update state
        if self._current_probability > self._threshold:
            self._state = MotionState.MOTION
        else:
            self._state = MotionState.IDLE
        
        if self.track_data:
            self.probability_history.append(self._current_probability)
            state_str = 'MOTION' if self._state == MotionState.MOTION else 'IDLE'
            self.state_history.append(state_str)
            if self._state == MotionState.MOTION:
                self._motion_count += 1
        
        return {
            'state': self._state,
            'probability': self._current_probability,
            'threshold': self._threshold
        }
    
    def _extract_features(self):
        """Extract 12 features from turbulence buffer using centralized extractor."""
        turb_buffer = self._context.turbulence_buffer
        buffer_count = len(turb_buffer)
        return extract_all_features(turb_buffer, buffer_count, self._last_amplitudes)
    
    def get_state(self):
        """Get current motion state."""
        return self._state
    
    def get_motion_metric(self):
        """Get current motion probability."""
        return self._current_probability
    
    def get_threshold(self):
        """Get current probability threshold."""
        return self._threshold
    
    def set_threshold(self, threshold):
        """Set probability threshold."""
        if 0.0 <= threshold <= 1.0:
            self._threshold = threshold
            return True
        return False
    
    def is_ready(self):
        """Check if buffer is full."""
        return self._context.buffer_count >= self._context.window_size
    
    def reset(self):
        """Reset detector state."""
        self._context.reset(full=True)
        self._state = MotionState.IDLE
        self._current_probability = 0.0
        self._motion_count = 0
        self.probability_history = []
        self.state_history = []
    
    def get_name(self):
        """Get detector name."""
        return "ML"
    
    @property
    def total_packets(self):
        """Total packets processed."""
        return self._packet_count
    
    def get_motion_count(self):
        """Get number of motion detections (for tracking)."""
        return self._motion_count
